json = {}
-- Internal functions.

local function kind_of(obj)
    if type(obj) ~= 'table' then return type(obj) end
    local i = 1
    for _ in pairs(obj) do
        if obj[i] ~= nil then i = i + 1 else return 'table' end
    end
    if i == 1 then return 'table' else return 'array' end
end

local function escape_str(s)
    local in_char = { '\\', '"', '/', '\b', '\f', '\n', '\r', '\t' }
    local out_char = { '\\', '"', '/', 'b', 'f', 'n', 'r', 't' }
    for i, c in ipairs(in_char) do
        s = s:gsub(c, '\\' .. out_char[i])
    end
    return s
end

-- Returns pos, did_find; there are two cases:
-- 1. Delimiter found: pos = pos after leading space + delim; did_find = true.
-- 2. Delimiter not found: pos = pos after leading space;     did_find = false.
-- This throws an error if err_if_missing is true and the delim is not found.
local function skip_delim(str, pos, delim, err_if_missing)
    pos = pos + #str:match('^%s*', pos)
    if str:sub(pos, pos) ~= delim then
        if err_if_missing then
            error('Expected ' .. delim .. ' near position ' .. pos)
        end
        return pos, false
    end
    return pos + 1, true
end

-- Expects the given pos to be the first character after the opening quote.
-- Returns val, pos; the returned pos is after the closing quote character.
local function parse_str_val(str, pos, val)
    val = val or ''
    local early_end_error = 'End of input found while parsing string.'
    if pos > #str then error(early_end_error) end
    local c = str:sub(pos, pos)
    if c == '"' then return val, pos + 1 end
    if c ~= '\\' then return parse_str_val(str, pos + 1, val .. c) end
    -- We must have a \ character.
    local esc_map = { b = '\b', f = '\f', n = '\n', r = '\r', t = '\t' }
    local nextc = str:sub(pos + 1, pos + 1)
    if not nextc then error(early_end_error) end
    return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
end

-- Returns val, pos; the returned pos is after the number's final character.
local function parse_num_val(str, pos)
    local num_str = str:match('^-?%d+%.?%d*[eE]?[+-]?%d*', pos)
    local val = tonumber(num_str)
    if not val then error('Error parsing number at position ' .. pos .. '.') end
    return val, pos + #num_str
end


-- Public values and functions.

function json.stringify(obj, as_key)
    local s = {} -- We'll build the string as an array of strings to be concatenated.
    local kind = kind_of(obj) -- This is 'array' if it's an array or type(obj) otherwise.
    if kind == 'array' then
        if as_key then error('Can\'t encode array as key.') end
        s[#s + 1] = '['
        for i, val in ipairs(obj) do
            if i > 1 then s[#s + 1] = ', ' end
            s[#s + 1] = json.stringify(val)
        end
        s[#s + 1] = ']'
    elseif kind == 'table' then
        if as_key then error('Can\'t encode table as key.') end
        s[#s + 1] = '{'
        for k, v in pairs(obj) do
            if #s > 1 then s[#s + 1] = ', ' end
            s[#s + 1] = json.stringify(k, true)
            s[#s + 1] = ':'
            s[#s + 1] = json.stringify(v)
        end
        s[#s + 1] = '}'
    elseif kind == 'string' then
        return '"' .. escape_str(obj) .. '"'
    elseif kind == 'number' then
        if as_key then return '"' .. tostring(obj) .. '"' end
        return tostring(obj)
    elseif kind == 'boolean' then
        return tostring(obj)
    elseif kind == 'nil' then
        return 'null'
    elseif kind == 'function' then
        return 'null'
    else
        error('Unjsonifiable type: ' .. kind .. '.')
    end
    return table.concat(s)
end

json.null = {} -- This is a one-off table to represent the null value.

function json.parse(str, pos, end_delim)
    pos = pos or 1
    if pos > #str then error('Reached unexpected end of input.') end
    local pos = pos + #str:match('^%s*', pos) -- Skip whitespace.
    local first = str:sub(pos, pos)
    if first == '{' then -- Parse an object.
        local obj, key, delim_found = {}, true, true
        pos = pos + 1
        while true do
            key, pos = json.parse(str, pos, '}')
            if key == nil then return obj, pos end
            if not delim_found then error('Comma missing between object items.') end
            pos = skip_delim(str, pos, ':', true) -- true -> error if missing.
            obj[key], pos = json.parse(str, pos)
            pos, delim_found = skip_delim(str, pos, ',')
        end
    elseif first == '[' then -- Parse an array.
        local arr, val, delim_found = {}, true, true
        pos = pos + 1
        while true do
            val, pos = json.parse(str, pos, ']')
            if val == nil then return arr, pos end
            if not delim_found then error('Comma missing between array items.') end
            arr[#arr + 1] = val
            pos, delim_found = skip_delim(str, pos, ',')
        end
    elseif first == '"' then -- Parse a string.
        return parse_str_val(str, pos + 1)
    elseif first == '-' or first:match('%d') then -- Parse a number.
        return parse_num_val(str, pos)
    elseif first == end_delim then -- End of an object or array.
        return nil, pos + 1
    else -- Parse true, false, or null.
        local literals = { ['true'] = true, ['false'] = false, ['null'] = json.null }
        for lit_str, lit_val in pairs(literals) do
            local lit_end = pos + #lit_str - 1
            if str:sub(pos, lit_end) == lit_str then return lit_val, lit_end + 1 end
        end
        local pos_info_str = 'position ' .. pos .. ': ' .. str:sub(pos, pos + 10)
        error('Invalid json syntax starting at ' .. pos_info_str)
    end
end

function Utils()
    local findInArray = function(array, fun)
        for _, it in pairs(array) do
            if fun(it) then return it end
        end
        return nil
    end

    local mapArray = function(array, fun)
        local mapped = {}
        for index, it in pairs(array) do
            mapped[index] = fun(it)
        end
        return mapped
    end

    local copy = function(self, t)
        if type(t) ~= "table" then return t end
        local meta = getmetatable(t)
        local target = {}
        for k, v in pairs(t) do
            if type(v) == "table" then
                target[k] = self:copy(v)
            else
                target[k] = v
            end
        end
        setmetatable(target, meta)
        return target
    end

    return {
        findInArray = findInArray,
        mapArray = mapArray,
        copy = copy
    }
end

utils = Utils()

function Item(initializer)
    if not initializer.id or not initializer.type then
        error("Id and type parameters are mandatory")
    end
    local id = initializer.id
    local type = initializer.type
    local use = function(target)
        error("'use' function isn't implemented' for item " .. id .. " of type " .. type)
    end
    if initializer.use then
        use = initializer.use
    end
    local countable = false
    if initializer.countable then
        countable = initializer.countable
    end

    return {
        id = id,
        type = type,
        use = use,
        countable = countable
    }
end

function Plant(initializer)
    initializer.type = 'plant'
    local it = Item(initializer)
    it.preparationTime = initializer.preparationTime;
    it.harvestValue = initializer.harvestValue;
    it.use = function(target)
        if not target or target.type ~= "field" then
            error("Can't apply '" .. it.id .. "', invalid target: " .. target)
        end
        if #target.queue > 0 then
            error("Already sowed with " .. target.queue)
        end
        table.insert(target.queue, utils:copy(it))
        target.endTime = os.time() * 1000 + it.preparationTime
        return utils:copy(target)
    end
    return it
end

function Field(initializer)
    initializer.type = 'field'
    local it = Item(initializer)
    it.queue = {}
    it.use = function(target)
        if not target or target.id ~= 'ground' then
            error("Can't apply '" .. it.id .. "', invalid target: " .. target)
        end
        return utils:copy(it)
    end
    return it
end

function StaticData()
    local itemTypes = {
        currency = "currency",
        foundation = "foundation",
        building = "building",
        tool = "tool",
        seed = "seed"
    }

    local items = {}

    items.softMoney = Item({
        id = "softMoney",
        type = itemTypes.currency
    });
    items.wateringCan = Item({
        id = "wateringCan",
        type = itemTypes.tool,
        uncountable = true
    });
    items.sickle = Item({
        id = "sickle",
        type = itemTypes.tool,
        uncountable = true,
        use = function(target)
            if not target or target.id ~= items.field.id then
                error("Can't apply 'sickle', invalid target: " .. target)
            end
            if #target.queue == 0 then
                error("Production queue is empty")
            end
            if os.time() * 1000 < target.endTime then
                error("Field is not ready yet. It will be ready after " .. (target.endTime - os.time() * 1000) .. " milliseconds")
            end
            local reaped = table.remove(target.queue, 1)
            target.endTime = nil
            target.currentProductionTimeLeft = nil
            bag.increaseCount(reaped.id, reaped.harvestValue)
            return utils:copy(target)
        end
    });
    items.wheat = Plant({
        id = "wheat",
        preparationTime = 10000,
        harvestValue = 3
    });
    items.carrot = Plant({
        id = "carrot",
        preparationTime = 50000,
        harvestValue = 3
    });
    items.ground = Item({
        id = "ground",
        type = itemTypes.foundation
    });
    items.field = Field({
        id = "field"
    });
    items.well = Item({
        id = "well",
        type = itemTypes.foundation
    });

    local getItemTypes = function()
        return utils:copy(itemTypes)
    end

    local getItems = function()
        return utils:copy(items)
    end

    return {
        getItemTypes = getItemTypes,
        getItems = getItems
    }
end

staticData = StaticData()

function Bag(exportData)
    local bagItems
    if exportData and type(exportData) == "table" then
        bagItems = exportData
    else
        bagItems = {
            {
                item = staticData.getItems().softMoney,
                count = 20
            },
            {
                item = staticData.getItems().wheat,
                count = 2
            },
            {
                item = staticData.getItems().wateringCan,
                count = 1
            }
        }
    end

    local getOrCreate = function(itemId)
        local found = utils.findInArray(bagItems, function(it) return it.item.id == itemId end)

        if found then return found
        else found = staticData.getItems()[itemId]
        end

        if not found then
            error("No item with id '" .. itemId .. "' have been found in application")
        end

        local newBagItem = { item = found, count = 0 }
        table.insert(bagItems, newBagItem)
        return newBagItem
    end

    local decreaseCount = function(itemId, count)
        local found = getOrCreate(itemId);
        if found.count < count then
            error("Not enough '" .. itemId .. "', need: " .. count .. ", available: " .. found.count)
        end
        found.count = found.count - count;
    end

    local increaseCount = function(itemId, count)
        local bagItem = getOrCreate(itemId)
        bagItem.count = bagItem.count + count;
    end

    local getCopyOfAllItems = function()
        return utils:copy(bagItems)
    end

    return {
        getOrCreate = getOrCreate,
        decreaseCount = decreaseCount,
        increaseCount = increaseCount,
        getCopyOfAllItems = getCopyOfAllItems
    }
end

bag = Bag()

function Farm(exportData)
    local FIELD_HEIGHT = 10;
    local FIELD_WIDTH = 10;
    local farm;

    if exportData and type(exportData) == "table" then
        farm = exportData
    else
        farm = {}
        for x = 1, FIELD_HEIGHT, 1 do
            farm[x] = {}
            for y = 1, FIELD_WIDTH, 1 do
                farm[x][y] = staticData.getItems().ground
            end
        end
    end

    local applyHandToCell = function(hand, target)
        if not hand or not hand.id then
            error("Invalid object in hand: " .. hand)
        end
        if not target or not target.x or not target.y then
            error("Invalid target object: " .. target)
        end
        target.x = target.x + 1 -- lua arrays start from 1
        target.y = target.y + 1 -- lua arrays start from 1
        if bag.getOrCreate(hand.id).count <= 0 then
            error("Not enough '" .. hand.id .. "'. Target: " .. json.stringify(target) .. ". Cell: " .. json.stringify(farm[target.x][target.y]))
        end
        local item = staticData.getItems()[hand.id]
        farm[target.x][target.y] = item.use(farm[target.x][target.y])
        bag.decreaseCount(hand.id, 1)
    end

    local updateTimerDeltas = function()
        for x = 1, #farm, 1 do
            for y = 1, #farm[x], 1 do
                if farm[x][y] and farm[x][y].endTime then
                    local delta = farm[x][y].endTime - os.time() * 1000
                    if delta > 0 then
                        farm[x][y].currentProductionTimeLeft = delta
                    else
                        farm[x][y].currentProductionTimeLeft = 0;
                    end
                end
            end
        end
    end

    local getOriginalFarmObject = function()
        updateTimerDeltas()
        return farm
    end

    return {
        applyHandToCell = applyHandToCell,
        getOriginalFarmObject = getOriginalFarmObject
    }
end

function Shop()
    local shopItems = {
        {
            item = staticData.getItems().field,
            buyPrice = 4,
            sellPrice = 1
        },
        {
            item = staticData.getItems().well,
            buyPrice = 0,
            sellPrice = 0
        },
        {
            item = staticData.getItems().wateringCan,
            buyPrice = 0,
            sellPrice = 0
        },
        {
            item = staticData.getItems().sickle,
            buyPrice = 0,
            sellPrice = 0
        },
        {
            item = staticData.getItems().wheat,
            buyPrice = 3,
            sellPrice = 1
        },
        {
            item = staticData.getItems().carrot,
            buyPrice = 15,
            sellPrice = 3
        }
    }
    local findShopItem = function(itemId)
        return utils.findInArray(shopItems, function(it)
            return it.item.id == itemId
        end)
    end

    local getCopy = function(itemId)
        local item = findShopItem(itemId)
        if not item then return nil end
        return utils:copy(item)
    end

    local getCopyOfAllItems = function()
        return utils:copy(shopItems)
    end

    local buy = function(itemId)
        local item = findShopItem(itemId)
        if not item then error("There is no shop item with id " .. itemId) end
        bag.decreaseCount(staticData.getItems().softMoney.id, item.buyPrice)
        bag.increaseCount(item.item.id, 1)
    end

    local sell = function(itemId)
        local count = bag.getOrCreate(itemId).count
        if count == 0 then
            error("Bag doesn't contain enough items with id " .. itemId)
        end
        local item = findShopItem(itemId);
        if not item then
            error("You can't sell item with id " .. itemId .. "because shop doesn't contain it")
        end
        bag.decreaseCount(item.item.id, 1);
        bag.increaseCount(staticData.getItems().softMoney.id, item.sellPrice)
    end

    return {
        getCopy = getCopy,
        getCopyOfAllItems = getCopyOfAllItems,
        buy = buy,
        sell = sell
    }
end

shop = Shop()

local commands = {
    get = "GET",
    buy = "BUY",
    sell = "SELL",
    apply = "APPLY"
};

function setState(dataString)
    local data = json.parse(dataString)
    bag = Bag(data.bag)
    farm = Farm(data.farm)
    shop = Shop()
end

function getDataAsString()

    return json.stringify({
        staticData = staticData.getItems(),
        bag = bag.getCopyOfAllItems(),
        farm = farm.getOriginalFarmObject(),
        shop = shop.getCopyOfAllItems()
    })
end

function commandHandler(requestString)
    local requestArray = json.parse(requestString)

    if type(requestArray) ~= "table" then
        error("API didn't recognised request array: " .. requestString)
    end

    for _, requestObject in pairs(requestArray) do
        if requestObject.command == commands.get then
            return getDataAsString()
        elseif requestObject.command == commands.buy then
            shop.buy(requestObject.hand.id)
        elseif requestObject.command == commands.sell then
            shop.sell(requestObject.hand.id)
        elseif requestObject.command == commands.apply then
            farm.applyHandToCell(requestObject.hand, requestObject.target)
        end
    end

    return getDataAsString()
end

setState("{}")